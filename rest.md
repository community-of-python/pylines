# Гайд по написанию REST

REST — это стиль, а не точный стандарт. Автор [Roy Fielding](https://en.wikipedia.org/wiki/Roy_Fielding) недоволен тем как все его идею имплементировали в жизнь, поэтому даже наличие swagger ui для него уже признак того, что REST вы не соблюдаете. Почему? Потому что в его идее настоящий REST — это только HATEOAS. Несколько авторов пытаются закрыть этот разрыв между ожиданиями и действительностью, вводя понятие [REST maturity levels](https://martinfowler.com/articles/richardsonMaturityModel.html).

Мы в этой позиции приняли положение сил зла и не имплементируем HATEOAS, а полагаемся на code first fastapi/litestar подход: пишем «ручки» и получаем к ним swagger ui.

Но всё таки мы хотим следовать core принципам REST архитектуры, которые мы сформулировали вот так. Рекомендуем следовать этим правилам и вам:

* «ручка», «хендлер», «эндпоинт» — так мы на жаргоне называем адрес апи, т.е. /rest/example/books/1/ — это ручка
* формат взаимодействия — JSON
* протокол — HTTP/2 или HTTP/3
* каждый адрес — это ресурс или сущность. Что такое «ресурс» или «сущность»? Обычно это какая-то структура с фиксированными полями. Ну, например, можете воспринимать это как таблицу в БД или pydantic модель, или и то и другое. Это грубое описание, но достаточное
  * отсюда возникает правило, что в адресе необходимо использовать существительные. Если присутствует глагол, то,  скорее всего, это не REST
  * глаголы, т.е. действия — это имена http методов (POST, PUT, PATCH, DELETE, GET)
  * обычно (не всегда) за каждой сущностью стоит 5 простых действий, мы называем это CRUD:
    * GET /rest/example/books/ — список сущностей
    * GET /rest/example/books/1/ — одна сущность
    * POST /rest/example/books/ — создать сущность
    * PUT /rest/example/books/1/ — обновить сущность
    * DELETE /rest/example/books/ — удалить сущность
  * действия могут быть пропущены. Т.е. иметь одну «ручку»GET /rest/example/books/ нормально 
* версионирование всё усложняет, не делайте его, если нет четкого понимания зачем. Часто нам это навязывают гайды или просто хочется следовать моде. Но поддерживать разные версии сложно и тяжело, а тестировать ещё сложнее. Версионирование нужно когда у вас есть круг неопределенных клиентов (супер частый случай: есть мобильные приложения). Делая REST внутри команды чаще всего версионирование не требуется. Так же, версия, философский момент, не часть сущности. Книга — это просто книга, а не КнигаВерсия1, КнигаВерсия2. Поэтому, мы чаще всего версионируем REST наиболее логичным по семантике HTTP способом: размещаем версию в Accept заголовке. Сами заголовки — это мета-информация по запросу, а версия вполне себе мета-информация. Пакет, который может с этим помочь, [лежит вот тут](https://github.com/community-of-python/fast-version)
* соглашения по построению адреса:
  * префикс /api/ не очень понятен, плюс оставляет не очень много пространства для маневра, поэтому мы используем следующие префиксы/layout:
    * /rest/\[имя-сервиса]/\[имя-сущности]/ для REST
    * /rpc/\[имя-сервиса]/\[действие-с-глаголом]/ для того, что в REST не укладывается, называем мы такие адреса RPC (remote procedure call), обычно в их именах содержаться глаголы. Например, /rpc/users/reorder-templates-tree/
  * слеши в конце мы стараемся закрывать
  * разделитель всех имен — дефис, потому что у него меньшая вероятность быть спутанным, например, с сущностями в python, т.к. у нас много чего полагается на подчеркивание и чем ваши имена будут явнее отличаться, тем проще будет отличать get параметры и урлы от остальных строк. Плюс у вас не будет возможности заводить одноименные переменные, т.к. всегда будет отличие в один символ
  * имя-сущности мы стараемся формулировать либо в одиночном, либо во множественном числе. Мне нравится множественное, но вы можете выбрать что нравится вам, однако помните, что в команде выбор должен быть унифицирован. Ничего нет хуже обнаружить /rest/some-service/books/ и /rest/some-service/user/ и гадать почему одно во множественном числе, а другое в единичном
* вложенный REST, несмотря на некоторые советы, не кажется удобным, поддерживаемым, понятным и простым. Т.е. адрес /rest/service/books/123/readers/12/books/2/ кажется непонятным, главное мы здесь не понимаем о какой сущности идёт речь, а как строить их, а главное, что во что вкладывается — это ужасно запутанная тема. Что если у нас появится /rest/service/readers/12/books/2/ и чем он будет отличаться от того урла выше? Некоторые скажут «да очевидно», но этих людей меньшая часть, остальные остановятся и задумаются. Поэтому я это определил это как «запах» от архитектуры. Вместо вложенного REST вы можете использовать GET параметры, дополнительно фильтруя выдачу. Например: GET /rest/example/books/?user-id=5. Это довольно семантичный подход + вы можете не беспокоясь о том что за чем следует собирать довольно сложные фильтры
* имена префиксов
  * /rest/\* — базовое REST API (админка, фронт)
  * /rpc/\* — базовое RPC API для тех же потребителей
  * /rest-internal/\*, /rpc-internal/\* — внутренние «ручки» между микросервисами
